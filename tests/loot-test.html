<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8" />
	<title>QUnit Test Suite</title>
	<link rel="stylesheet" href="../lib/qunit/qunit.css" type="text/css" media="screen">
	<script type="text/javascript" src="../lib/qunit/qunit.js"></script>
	<script type="text/javascript" src="../lib/jquery-1.6.js"></script>
	<script type="text/javascript" src="../lib/jquery.mockjax.js"></script>
	<script type="text/javascript" src="../src/loot.js"></script>
	<script type="text/javascript" src="../src/loot.sauce.js"></script>
	<script type="text/javascript">

		module("loot");

		test("$new", function() {

			expect(12);

			var person = {
				firstName: "john",
				age: 30
			};

			var jim = $new(person);
			jim.firstName = "jim";

			ok(person.firstName == "john", "changes to new instance do not affect original object");
			ok(person.age == "30", "untouched properties on new instance inherit values form original object");
			ok(jim.firstName == "jim", "changes to new instance took place");
			delete jim.firstName;
			ok(jim.firstName == "john", "deleting modification on new instance allows original value to shine through");
			delete jim.firstName;
			ok(person.firstName == "john", "deleting inherited value has no effect on origin");
			ok(jim.firstName == "john", "deleting inherited value has no effect on new instance");
			person.age = 0;
			ok(jim.age === 0, "modifications on original get inherited by new instance");

			var initScope,
				initruns = 0,
				initTest = $new({
					init: function() {
						var myRunCount = ++initruns;
						initScope = this;
						var sharedSecret = "shared"+myRunCount;
						this.getSharedSecret = function() {
							return sharedSecret;
						};
						this.setSharedSecret = function(val) {
							sharedSecret = val + "" + myRunCount;
						};
					}
				});

			equals(initScope, initTest, "init function is properly called");
			equals(initTest.getSharedSecret(), "shared1", "init function enables providing access to private members");

			var sharingSecrets = $new(initTest);
			equals(sharingSecrets.getSharedSecret(), "shared2", "closures from init functions are unique to instances");
			sharingSecrets.setSharedSecret("changed");
			equals(initTest.getSharedSecret(), "shared1", "modifications to closures from child do not affect ancestor");
			initTest.setSharedSecret("changed");
			equals(sharingSecrets.getSharedSecret(), "changed2", "modifications to shared closures from ancestor do not affect child");
		});


		test("$speak", function() {
			expect(27);

			var myBlankSpeaker = $speak({name:"myBlankSpeaker"});

			ok($isSpeaker(myBlankSpeaker), "calling $speak without arguments returns a new speaker");

			var mySpeaker = $speak({
				name: "mySpeaker",
				firstName: "",
				age: 0
			});

			var mySpeaker3 = $speak({
				firstName: "",
				age: 0
			});

			ok($isSpeaker(mySpeaker), "calling $speak with arguments returns a new speaker");

			ok($isSpeaker(myBlankSpeaker) && $isSpeaker(myBlankSpeaker), "$isSpeaker works properly");

			myBlankSpeakerTestResponses = 0;
			myBlankSpeakerTestLastTopic = null;
			myBlankSpeakerTestLastMessage = null,
			myBlankSpeakerTestLastSpeaker = null,
			myBlankSpeakerTestLastScope = null,
			myBlankSpeaker.listen("test", function(message, topic, speaker) {
				myBlankSpeakerTestResponses++;
				myBlankSpeakerTestLastTopic = topic;
				myBlankSpeakerTestLastMessage = message;
				myBlankSpeakerTestLastSpeaker = speaker;
				myBlankSpeakerTestLastScope = this;

			});

			mySpeakerTestResponses = 0;
			mySpeakerTestLastTopic = null;
			mySpeakerTestLastMessage = null,
			mySpeakerTestLastSpeaker = null,
			mySpeakerTestLastScope = null,
			mySpeaker.listen("test", function(message, topic, speaker) {
				if(mySpeakerTestResponses > 20){return;}
				console.log(arguments);
				console.log((speaker && speaker === myBlankSpeaker));
				mySpeakerTestResponses++;
				mySpeakerTestLastTopic = topic;
				mySpeakerTestLastMessage = message;
				mySpeakerTestLastSpeaker = speaker;
				mySpeakerTestLastScope = this;
			});

			myBlankSpeaker.tell("test", "this is a test");
			ok(myBlankSpeakerTestResponses == 1, "properly responded to simple tell");
			ok(myBlankSpeakerTestLastMessage == "this is a test", "responder received the message as first arg");
			ok(myBlankSpeakerTestLastTopic == "test", "received the topic as second arg");
			ok(myBlankSpeakerTestLastSpeaker === myBlankSpeaker, "properly received the original speaker for 3rd arg");
			ok(myBlankSpeakerTestLastScope === myBlankSpeaker, "scope was properly the speaker that was told");

			ok(mySpeakerTestResponses == 0, "message was not shared with others");



			mySpeaker.listensTo(myBlankSpeaker);

			myBlankSpeaker.tell("test", "this is a test with sharing");
			ok(myBlankSpeakerTestResponses == 2, "properly responded to simple tell");
			ok(myBlankSpeakerTestLastMessage == "this is a test with sharing", "responder received the message");

			ok(mySpeakerTestResponses == 1, "properly responded to shared message");
			equals(mySpeakerTestLastTopic, "test", "properly received the shared topic as first arg");
			ok(mySpeakerTestLastMessage == "this is a test with sharing", "responder received the message as second arg");
			ok(mySpeakerTestLastSpeaker == myBlankSpeaker, "properly received the original speaker for speaker in 3rd arg since it was a shared message");
			ok(mySpeakerTestLastScope == mySpeaker, "scope was properly the speaker that was told");

			mySpeaker3TestResponses = 0;
			mySpeaker3TestLastTopic = null;
			mySpeaker3TestLastMessage = null,
			mySpeaker3TestLastSpeaker = null,
			mySpeaker3TestLastScope = null,
			mySpeaker3.listen("test", function(message, topic, speaker) {
				mySpeaker3TestResponses++;
				mySpeaker3TestLastTopic = topic;
				mySpeaker3TestLastMessage = message;
				mySpeaker3TestLastSpeaker = speaker;
				mySpeaker3TestLastScope = this;
			});

			mySpeaker.talksTo(mySpeaker3);
			myBlankSpeaker.tell("test", "this is a test with a sharing chain");
			
			ok(mySpeaker3TestResponses == 1, "third party (2nd share) properly responded to");
			ok(mySpeaker3TestLastTopic == "test", "properly received the topic as first arg");
			ok(mySpeaker3TestLastMessage == "this is a test with a sharing chain", "responder received the message as second arg");
			ok(mySpeaker3TestLastSpeaker === myBlankSpeaker, "properly received original speaker for 3rd arg");
			ok(mySpeaker3TestLastScope === mySpeaker3, "scope was properly the speaker that was told");

			mySpeaker3.selectiveHearing = function(message, topic, speaker) {
				ok(this === mySpeaker3, "selective hearing function properly scoped");
				ok(speaker === mySpeaker3, "selective hearing speaker is the original speaker for non shared messages");
				return !(topic == "test"); // ignore test messages
			};
			mySpeaker3.tell("test", "testing selectiveHearing");
			console.log("for: selective hearing ignores items when truth test returns false", mySpeaker3TestResponses);
			ok(mySpeaker3TestResponses == 1, "selective hearing ignores items when truth test returns false");


			mySpeaker3.selectiveHearing = function(message, topic, speaker) {
				ok(this === mySpeaker3, "selective hearing function properly scoped");
				ok(speaker === mySpeaker, "selective hearing speaker properly ser for shared messages");
				return (topic == "test"); // ignore all but test messages
			};

			mySpeaker.tell("test", "testing selectiveHearing again");
			ok(mySpeaker3TestResponses == 2, "selective hearing listens to items when truth test returns true");

		});


		test("$make", function() {
			expect(15);

			var aPerson = {
				firstName: "",
				age: 0,
				language: "en"
			};

			var aParent = $new(aPerson);
			aParent.firstName = "john";
			aParent.lastName = "doe";
			aParent.age = 40;
			aParent.city = "nevis";
			aParent.state = "MN";
			aParent.language = "cz";


			var aKid = $new(aPerson);
			aKid.firstName = "jim";
			aKid.age = 12;


			var aStudent = $new(aPerson);
			aStudent.school = "ISD 128";
			aStudent.grade = 5;

			// basic make behavior: prototype, extension, mixin
			var jim = $make(aParent, aKid, aStudent);

			equals(jim.language, "en", "inherited property on extender overwrites the prototype inherited value, while mixin inherited property is ignored");
			equals(jim.age, 12, "extension property overwrites inherited property from prototype");
			equals(aStudent.age, 0, "mixin inherits age == 0");
			equals(jim.age, 12, "property inherited on mixin is not applied");
			equals(jim.grade, 5, "property local to mixin is applied");
			equals(jim.lastName, "doe", "prototype property exists when not set by extension or mixin");

			aKid.age = 15;
			equals(jim.age, 12, "there is NO prototypal inheritance between new object and extension object");
			aStudent.grade = 8;
			equals(jim.grade, 5, "there is NO prototypal inheritance between new object and mixin object");
			aParent.lastName = "johnson";
			equals(jim.lastName, "johnson", "there IS prototypal inheritance between new object and prototype object");
			aPerson.country = "us";
			equals(aParent.country, "us", "prototype inherits new properties when they are added to its prototype object");
			equals(jim.country, "us", "inheritance chaining: new object also inherits new properties when they are added to its prototype's prototype object");



			
			// init callback support
			var afterProtoMake = 0,
				afterextensionMake = 0,
				afterMixinMake = 0;

			var initTester = $make({
					init: function() {
						afterProtoMake = this;
					}
				},{
					init: function() {
						afterextensionMake = this;
					}
				},{
					init: function() {
						afterMixinMake = this;
					}
				});

			equals(initTester, afterProtoMake, "init on prototype called properly");
			equals(initTester, afterextensionMake, "init on extender called properly");
			equals(initTester, afterMixinMake, "init on mixin called properly");
			equals(initTester.init.length, 3, "init is an array of all init methods after make");

		});




		test("$make + $speak integration", function() {

			expect(8);

			aTestResponsesMA = 0;
			var myAudience = $speak({name:"myAudience"}).listen("aTest", function(subject, message, source) {
				aTestResponsesMA++;
			});

			aTestResponsesMM = 0;
			var myMessenger = $speak({name: "myMessenger"}).listen("aTest", function(subject, message, source) {
				aTestResponsesMM++;
			}).talksTo(myAudience);

			var newMessenger = $make(myMessenger, {name: "newMessenger"});

			same(newMessenger._listeningFor, {}, "_listeningFor object is cleared out so we don't inherit/share them");
			same(newMessenger._audience, [], "_audience array is cleared out so we don't inherit/share audiences");



			aTestResponsesNM = 0;
			newMessenger.listen("aTest", function(subject, message, source) {
				aTestResponsesNM++;
			});

			myMessenger.tell("aTest", "this is a test");

			equals(aTestResponsesMM, 1, "preexisting handlers work as expected");
			equals(aTestResponsesMA, 1, "preexisting message sharing works as expected");
			equals(aTestResponsesNM, 0, "events do not bubble by default");

			var forceBubble = $make(myMessenger, {name: "forceBubble", shareMessages: true});
			aTestResponsesFB = 0;
			forceBubble.listen("aTest", function(subject, message, source) {
				aTestResponsesFB++;
			});

			myMessenger.tell("aTest", "this is a test");
			equals(aTestResponsesFB, 1, "shareMessages attribute makes new object listen to prototype messages");

			var inheritBubble = $make(forceBubble, {name: "inheritBubble"});
			aTestResponsesIB = 0;
			inheritBubble.listen("aTest", function(subject, message, source) {
				aTestResponsesIB++;
			});

			myMessenger.tell("aTest", "this is a test");
			equals(aTestResponsesIB, 1, "shareMessages attribute persists as you make new objects creating a chain of message sharing (bubbling)");

			var preventBubble = $make(inheritBubble, {name: "preventBubble", dontShareMessages: true});
			aTestResponsesPB = 0;
			preventBubble.listen("aTest", function(subject, message, source) {
				aTestResponsesPB++;
			});

			myMessenger.tell("aTest", "this is a test");
			equals(aTestResponsesPB, 0, "dontShareMessages=true property can be used to break the message chain");


		});


		test("$copy", function() {

			expect(5);

			var objA = {name: "objA"};
			var objB = {name: "objB", testObj: {array:[1, "string", {object:{name:"hey", age: 23} }, [0,2, 3, 5, [0, 0, 0]] ], func: function(){return this;}}};

			var aCopy = $copy(objA);
			same(aCopy, objA, "deep copy of a simple object works");

			objA.name = "objectA";
			ok(aCopy.name === "objA", "changes on simple object do not transfer to copy");

			var bCopy = $copy(objB);
			same(bCopy, objB, "deep copy of a complex object works");

			objB.testObj.array[2].object.name = "yo";
			ok(bCopy.testObj.array[2].object.name === "hey", "changes on complex object do not transfer to copy");

			var b2Copy = $new(objB);
			b2Copy.name = "b2";
			b2Copy.custom = "owned";

			var base = {
				name: "b2",
				custom: "owned"
			};

			var newB = $copy(b2Copy, function(key, source) {
				return source.hasOwnProperty(key);
			});

			same(newB, base, "filter function works properly");

		});


		test("$merge", function() {

			expect(3);

			var objA = {name: "objA"};
			var objB = {name: "objB", custom: "owned", testObj: {array:[1, "string", {object:{name:"hey", age: 23} }, [0,2, 3, 5, [0, 0, 0]] ], func: function(){return this;}}};

			$merge(objA, objB);
			same(objB, objA, "properly augments the provided target object");

			// test filter method that only allows owned properties
			var b2Copy = $new(objB);

			var base = {
				name: "b2",
				custom: "owned"
			};

			var augment = {
				name: "b2",
				custom: "owned"
			};

			$merge(augment, b2Copy, function(key, source) {
				return source.hasOwnProperty(key);
			});

			same(augment, base, "filter function works properly");


			$merge(augment, b2Copy);

			same(augment, b2Copy, "will copy over inherited properties by default");

		});


		test("$node", function() {

			expect(7);

			var node = $node();
			same(node.toString(), "<div></div>", "empty div by default");

			node.set("id", "test");
			same(node.toString(), '<div id="test"></div>', "simple set attr works fine");
			console.log(node.toString());

			node.set({
				"class": "someClass sidebar",
				title: "this is a good title",
				id: null
			});

			var expectedNodeStr = '<div class="someClass sidebar" title="this is a good title"></div>';

			same(node.toString(), expectedNodeStr, "complex set attr, with spec object and attr removal works fine");
			console.log(node.toString());

			var nextNode = $node("div");
			nextNode.set("id", "next");
			nextNode.append(node);
			console.log(nextNode.toString());
			same(nextNode.toString(), '<div id="next">'+expectedNodeStr+'</div>', "simple append works fine");

			console.log(nextNode.children.toString());
			same(expectedNodeStr, nextNode.children.toString(), "children.toString works fine");

			nextNode.append([node, $node(), $node()]);

			same(nextNode.toString(), '<div id="next">'+expectedNodeStr+expectedNodeStr+'<div></div><div></div></div>', "array append works fine");

			var p = $node("p");
			var textNode = 'this is some text with some <html><p>in it</p></html>';
			p.append(textNode);
			console.log(p.toString());
			nextNode.append(p);
			same(p.toString(), "<p>"+$escapeHTML(textNode)+"</p>", "text append works fine");

		});



		test("$el", function() {

			expect(0);

			$el.outputStrings(false);
			var div = $el("div");
			div.id = "testdiv";

			console.log(typeof div, div, div.toString());
			document.body.appendChild(div);

			var items = [ 1, 2, 3, 4];
			var div2 = $el('div#message', [
							$el('a.biglink', {href: 'http://www.google.com'}, 'A link to Google'),
							$el('ul', $map(items, function(item) {
									return $el('li.item', item + '. Item');
								})
							)
						]);

			div.appendChild(div2);
			console.log(typeof div2, div2, div.innerHTML);

			$el.outputStrings(true);
			var div3 = $el('div#message', [
							$el('a.biglink', {href: 'http://www.google.com'}, ['A link to Google']),
							$el('ul', $map(items, function(item) {
									return $el('li.item', [item + '. Item']);
								})
							)
						]);

			console.log(typeof div3, div3, div3.toString(), div.innerHTML);
			console.log(div3.toString());
			console.log(div.innerHTML);

			same(div.innerHTML, div3.toString(), "string mode and dom mode html output is the same");

			$id("testdiv").innerHTML = "";
		});

		

		test("$define, $schema, $model", function() {

			var data = {
				test: 1,
				foo: "bar",
				allYourBase: "are belong to us"
			};

			

			$define("testSchema");

			// start with blank model
			var m = $model("testSchema");

			m.listen("change", function(msg) {
				if (msg.test) {
					same(msg, {test:1}, "change event is fired providing the change-set");
				} else {
					same(msg, {
						foo: "bar",
						allYourBase: "are belong to us"
					}, "change event is fired providing the changeset");
				}
			});

			m.set("test", 1);
			m.set({
				foo: "bar",
				allYourBase: "are belong to us"
			});

			var t = m.get("test");
			ok(t === 1, "single key get");

			t = m.get("test", "foo");
			same(t, {test: 1, foo: "bar"}, "multi-key get using arguments");

			t = m.get(["test", "foo"]);
			same(t, {test: 1, foo: "bar"}, "multi-key get using an array");

			t = m.get();
			same(t, {test: 1, foo: "bar", allYourBase: "are belong to us"}, "get model (no arguments)");

			// initial set on model call
			var x = $model("testSchema", {
				test: 1,
				foo: "bar",
				allYourBase: "are belong to us"
			});

			t = x.get("test");
			ok(t === 1, "single key get");

			t = x.get("test", "foo");
			same(t, {test: 1, foo: "bar"}, "multi-key get using arguments");

			t = x.get(["test", "foo"]);
			same(t, {test: 1, foo: "bar"}, "multi-key get using an array");

			t = x.get();
			same(t, {test: 1, foo: "bar", allYourBase: "are belong to us"}, "get model (no arguments)");

			x.set("test");
			t = x.get("test");
			ok(t === undefined, "set without a second argument deletes");


			// testing $models
			var m2 = $models("testSchema");

			ok($isArray(m2), "$models returns an array when provided a valid schema type");
			ok( (m2.length === 2) && m2[0] === m && m2[1] === x , "$models returns an array of all model instances created under the provided schema");


			// testing setting things to falsy values
			x.set("bar", 5);

			var falsy = {
				test: 0,
				foo: undefined,
				allYourBase: null,
				bar: false,
				nully: null,
				falsy: false,
				zeroy: 0,
				undefinedy: undefined
			};

			x.set(falsy);
			t = x.get();
			same(t, falsy, "set without a second argument sets to undefined");

			// testing model instance destruction
			x.listen("drop", function(msg) {
				same(this.get(), falsy, "drop event fired providing last opportunity to deal with the model and its values");
			});

			x.drop();
			ok(x.get == undefined, "methods no longer exist on model after drop");

			ok(m2.length == 1 && m2[0] === m, "the killed instance is removed from the instances array");

			// todo, drop, various events, validators, computed values, error conditions
			var itemsKilled = 0;
			m.listen("drop", function() {
				itemsKilled++;
			});

			$schema.listen("drop", function(msg) {
				same(msg, {schema:"testSchema"}, "schema drop event fired with message of dropped schema type string for message")
				ok(itemsKilled === 1, "all model instances removed on schema drop")
			});

			$schema("testSchema").drop();

			$schema.listen("created", function(msg, type, speaker) {
				console.log("created",arguments);
				ok(msg, "created event was fired");
			});

			// test schema cration with defaults, validators and computed values
			var $validateWtih = function(fn, msg) {
				return function(val) {
					return fn(val) ? true : msg;
				}
			};

			$define("dog", {
				defaults: {
					// computed value
					color: "brown",
					info: function() {
						return (this.name || "unknown") + " is " + (this.age || "unknown") + " years old " + (this.breed || "unknown") + " breed";
					}
				},
				validate: {
					name: $validateWtih($isString, "String Required"),
					age: $validateWtih($isNumber, "Number Required"),
					breed: $validateWtih($isString, "String Required")
				}
			});

			var dog1 = $model("dog");
			var info = "unknown is unknown years old unknown breed";

			ok(dog1.get("info") === info, "computed values work as expected");
			ok(dog1.get("color") === "brown", "default values work as expected");

			console.log($schema("dog"));

			$schema("dog").listen("validatonFailed", function(msg) {
				console.log(msg);
				if (msg.failed.name) {
					ok(msg.failed.name === "String Required", "validators can return a string explaining a failure")
				}
			});

			dog1.set("name", 5);
			dog1.set({
				name: null,
				age: null,
				breed: "pointer"
			});

		});


		test("$view", function() {
			expect(5);
			$el.outputStrings(false);
			var parentNode = $el("div#parentNode");


			console.log(parentNode, $isElement(parentNode));
			document.body.appendChild(parentNode);

			var mData = {
				test: 1,
				foo: "bar",
				allYourBase: "are belong to us"
			};

			$define("testSchema2");

			// start with blank model
			var m = $model("testSchema2", mData);
			var html;
			var renderFn = function(data, changes, view) {
				console.log("view renderFn", arguments);
				ok(data === m.get(), "first argument is model values object");
				ok(typeof changes === "object", "second argument is model changes object");
				ok(view === testView, "third argument is the view");
				ok(true, "view was rendered");
				html = "<div>all your html " + data.allYourBase + "</div>";
				return html;
			};

			var testView = $view("testSchema2", {
				node: parentNode,
				model: "testSchema2",
				render: renderFn
			});

			console.log(testView);

			var aTestView = testView(mData);

			console.log(aTestView);
//
			aTestView.update();

			ok(parentNode.innerHTML === html, "view node was properly updated");
		});

		test("$async.each", function() {
			expect(12);
			stop();
			var work = [1,2,3];
			var finishOrder = [];
			var delays = [100, 1, 10];


			// with error
			var finishOrder2 = [];
			var iterator2 = function(done, val, key, obj) {
				console.log("provided each iterator", arguments);
				ok(true, "iterator fired");
				setTimeout(function() {
					finishOrder2.push(key);
					done("error");
				}, delays[key]);
			};

			$async.each(work, iterator2, function(error, obj) {
				console.log("each callback", arguments);
				ok(true, "callback fired");
				ok(error === "error", "error was handled");
				ok(obj === work, "second argument in final callback is the object iterated over");
				same(finishOrder2, [1], "finish order was as expected");
			});

			// without error
			var iterator = function(done, val, key, obj) {
				console.log("provided each iterator", arguments);
				ok(true, "iterator fired");
				setTimeout(function() {
					finishOrder.push(key);
					done();
				}, delays[key]);
			};

			$async.each(work, iterator, function() {
				console.log("each callback", arguments);
				ok(true, "callback fired");
				same(finishOrder, [1,2,0], "finish order was as expected");
				start();
			});
		});

		test("$async.eachSeries", function() {
			expect(10);
			stop();
			var work = [1,2,3];
			var finishOrder = [];
			var delays = [100, 1, 10];


			// with error
			var finishOrder2 = [];
			var iterator2 = function(done, val, key, obj) {
				console.log("provided each iterator", arguments);
				ok(true, "iterator fired");
				setTimeout(function() {
					finishOrder2.push(key);
					done("error");
				}, delays[key]);
			};

			$async.eachSeries(work, iterator2, function(error, obj) {
				console.log("each callback", arguments);
				ok(true, "callback fired");
				ok(error === "error", "error was handled");
				ok(obj === work, "second argument in final callback is the object iterated over");
				same(finishOrder2, [0], "finish order was as expected");
			});

			// without error
			var iterator = function(done, val, key, obj) {
				console.log("provided eachSeries iterator", arguments);
				ok(true, "iterator fired");
				setTimeout(function() {
					finishOrder.push(key);
					done();
				}, delays[key]);
			};

			$async.eachSeries(work, iterator, function() {
				console.log("each callback", arguments);
				ok(true, "callback fired");
				same(finishOrder, [0,1,2], "finish order was as expected");
				start();
			});

		});

		test("$async.map", function() {
			expect(10);
			stop();
			var work = [1,2,3];
			var finishOrder = [];
			var delays = [100, 1, 10];
			var resultsObj;
			var valObj;
			var keyObj;
			var objObj;

			var iterator = function(push, val, key, result, obj) {
				console.log("iterator", arguments);
				ok(true, "iterator fired");
				setTimeout(function() {
					finishOrder.push(key);
					valObj = val;
					keyObj = key;
					resultsObj = result;
					objObj = obj;
					push(null, val * 2);
				}, delays[key]);
			};

			$async.map(work, iterator, function(err, result, obj) {
				console.log("map callback", arguments);
				ok(true, "callback fired");
				same(finishOrder, [1,2,0], "finish order was as expected");
				same(result, [2,4,6], "result order was as expected");
				ok(valObj === 1, "second argument for iterator function is the value");
				ok(keyObj === 0, "third argument for iterator function is the key/index");
				ok(resultsObj === result, "fourth argument for iterator function is the result");
				ok(objObj === work, "fifth argument for iterator function is the object/array being iterated over");
				start();
			});
		});

		test("$async.mapSeries", function() {
			expect(10);
			stop();
			var work = [1,2,3];
			var finishOrder = [];
			var delays = [100, 1, 10];
			var resultsObj;
			var valObj;
			var keyObj;
			var objObj;

			var iterator = function(push, val, key, result, obj) {
				console.log("iterator", arguments);
				ok(true, "iterator fired");
				setTimeout(function() {
					finishOrder.push(key);
					valObj = val;
					keyObj = key;
					resultsObj = result;
					objObj = obj;
					push(null, val * 2);
				}, delays[key]);
			};

			$async.mapSeries(work, iterator, function(err, result, obj) {
				console.log("mapSeries callback", arguments);
				ok(true, "callback fired");
				same(finishOrder, [0,1,2], "finish order was as expected");
				same(result, [2,4,6], "result order was as expected");
				ok(valObj === 3, "second argument for iterator function is the value");
				ok(keyObj === 2, "third argument for iterator function is the key/index");
				ok(resultsObj === result, "fourth argument for iterator function is the result");
				ok(objObj === work, "fifth argument for iterator function is the object/array being iterated over");
				start();
			});
		});


		test("$parallel", function() {

			expect(22);
			stop();
			
			var runs = 0;
			var run = function(i) {
				runs++;
				console.log("called from " + i + " runs "+ runs);
				if(runs === 3) {
					runs = 0;
					ok(true, "call a bunch of functions in any order signature: all functions ran");
				}
			};

			var runOrder = [];

			var func1 = function(done, key, result) {
				setTimeout(function() {
					console.log("task", arguments);
					run(1);
					runOrder.push(1);
					done(null, 2);
				}, 100);
			};

			var func2 = function(done, key, result) {
				setTimeout(function() {
					console.log("task", arguments);
					run(2);
					runOrder.push(2);
					done(null, 4);
				}, 1);
			};

			var func3 = function(done, key, result) {
				setTimeout(function() {
					console.log("task", arguments);
					run(3);
					runOrder.push(3);
					done(null, 6);
				}, 10);
			};
			
			$parallel(func1, func2, func3);

			$parallel([func1, func2, func3], function(err, result) {
				console.log("$parallel 2", arguments);
				same(result, [2,4,6], "result is as expected");
				same(runOrder, [2,2,3,3,1,1], "run order is as expected");
				ok(true, "array of functions with callback signature: all functions ran");
			});

			var runOrder1 = [];
			var delays = [100, 1, 10];
			var work = [5,6,7];
			
			$parallel([5,6,7], function(push, val, key, results, obj) {
				setTimeout(function() {
					run(key);
					ok($isNumber(val) && val > 4, "val param is correct");
					ok($isNumber(key) && key < 3, "key param is correct");
					runOrder1.push(key);
					push(null, val*2);
				}, delays[key]);
			});

			var runOrder2 = [];
			$parallel([5,6,7], function(push, val, key, results, obj) {
				console.log("$parallel 4", arguments);
				setTimeout(function() {
					run(key);
					ok($isNumber(val) && val > 4, "val param is correct");
					ok($isNumber(key) && key < 3, "key param is correct");
					runOrder2.push(key);
					push(null, val*2);
				}, delays[key]);
			}, function(err, result) {
				ok(true, "array of functions with callback signature: all functions ran");
				same(runOrder2, [1,2,0], "run order is as expected");
				same(result, [10,12,14], "result is as expected");
				start();
			});

			console.log("done with $parallel");

		});

		test("$series", function() {

			expect(22);
			stop();

			var runs = 0;
			var run = function(i) {
				runs++;
				console.log("called from " + i + " runs "+ runs);
				if(runs === 3) {
					runs = 0;
					ok(true, "call a bunch of functions in any order signature: all functions ran");
				}
			};

			var runOrder = [];

			var func1 = function(done, key, result) {
				setTimeout(function() {
					console.log("task", arguments);
					run(1);
					runOrder.push(1);
					done(null, 2);
				}, 100);
			};

			var func2 = function(done, key, result) {
				setTimeout(function() {
					console.log("task", arguments);
					run(2);
					runOrder.push(2);
					done(null, 4);
				}, 1);
			};

			var func3 = function(done, key, result) {
				setTimeout(function() {
					console.log("task", arguments);
					run(3);
					runOrder.push(3);
					done(null, 6);
				}, 10);
			};

			$series(func1, func2, func3);

			$series([func1, func2, func3], function(err, result) {
				console.log("$series 2", arguments);
				same(result, [2,4,6], "result is as expected");
				same(runOrder, [1,1,2,2,3,3], "run order is as expected");
				ok(true, "array of functions with callback signature: all functions ran");
			});

			var runOrder1 = [];
			var delays = [100, 1, 10];
			var work = [5,6,7];

			$series([5,6,7], function(push, val, key, results, obj) {
				setTimeout(function() {
					run(key);
					ok($isNumber(val) && val > 4, "val param is correct");
					ok($isNumber(key) && key < 3, "key param is correct");
					runOrder1.push(key);
					push(null, val*2);
				}, delays[key]);
			});

			var runOrder2 = [];
			$series([5,6,7], function(push, val, key, results, obj) {
				console.log("$series 4", arguments);
				setTimeout(function() {
					run(key);
					ok($isNumber(val) && val > 4, "val param is correct");
					ok($isNumber(key) && key < 3, "key param is correct");
					runOrder2.push(key);
					push(null, val*2);
				}, delays[key]);
			}, function(err, result) {
				ok(true, "array of functions with callback signature: all functions ran");
				same(runOrder2, [0,1,2], "run order is as expected");
				same(result, [10,12,14], "result is as expected");
				start();
			});

			console.log("done with $parallel");

		});

//		test("loot.sauce.io", function() {
//
//			expect(20);
//
//			// setup mock data source
//			$.mockjax({
//				url: '/test',
//				responseTime: 200,
//				status: 200, // 500 error
//				response: function() {
//					this.responseText = JSON.stringify({msg: "Hello world!"});
//				}
//			});
//
//			$.mockjax({
//				url: '/err',
//				responseTime: 200,
//				status: 500, // 500 error
//				response: function() {
//					this.responseText = "error";
//				}
//			});
//
//			stop();
//
//			$io.listen("io:start:", function(msg, type) {
//				console.log(type);
//				console.log(msg);
//				ok(type.match(/^io:start/), "io:start event fires");
//				ok(this == $io, "'this' is sauce.io");
//			});
//
//			$io.listen("io:success", function(msg, type) {
//				console.log(type);
//				console.log(msg);
//				ok(type.match(/^io:success/), "io:success event fires");
//				ok(msg.val.msg == "Hello world!", "received the message");
//				ok(msg.req.b == 4, "received the original req");
//				ok(msg.xhr, "received the xhr");
//				ok(msg.url == "/test", "received the url");
//				ok(this == $io, "'this' is sauce.io");
//			});
//
//
//			$io.listen("io:error", function(msg, type) {
//				console.log(type);
//				console.log(msg);
//				ok(type.match(/^io:error/), "io:error event fires");
//				ok(this == $io, "'this' is sauce.io");
//				start();
//			});
//
//			$io("/test", {b:4, a:1});
//			$io("/test", {b:4, a:1});
//			$io("/err", {b:4, a:1});
//
//		});
//
//		test("loot.sauce.io more io", function() {
//
//			expect(5);
//
//			$.mockjax({
//				url: '/test2',
//				responseTime: 200,
//				status: 200, // 500 error
//				response: function() {
//					this.responseText = JSON.stringify({msg: "Hello world!"});
//				}
//			});
//
//			// alternate one-off non-pub-sub syntax for io with start, success and error handlers
//			var startFired = 0,
//				successFired = 0,
//				errorFired = 0;
//
//			stop();
//
//			console.log("non evented callbacks");
//			$io.ignore();
//
//			setTimeout(function() {
//				$io("/test2", {b:5, a:3}, {
//					start: function(msg, type) {
//						console.log(type);
//						console.log(msg);
//						startFired++;
//						ok(type.match("io:start"), "io:start event fires");
//						ok(this == $io, "'this' is sauce.io");
//					},
//					success: function(msg, type) {
//						console.log(type);
//						console.log(msg);
//						successFired++;
//						ok(type.match("io:success"), "io:success event fires");
//						ok(this == $io, "'this' is sauce.io");
//						ok(errorFired === 0, "error handler didn't fire");
//					},
//					error: function(msg, type) {
//						console.log(type);
//						console.log(msg);
//						errorFired++;
//					}
//				});
//			}, 500);
//
//			setTimeout(function() {
//				start();
//			},1000);
//
//		});
//
//
//		test("loot.sauce.cache", function() {
//
//			expect(16);
//
//			var url = "/test",
//				testReq1 = {a:3, b:6, blah:"text"},
//				testReq2 = {a:3, b:6, blah:{h:5}},
//				testVal = {my:"val"},
//				testMetaData = {more:"metadata"};
//
//			ok($cache.getKey(url) == "/test", "cacheKeys use just the url if no req provided");
//			ok($cache.getKey(url, testReq1) == '/test[a:3,b:6,blah:text]', "cacheKeys stringify req objects, strings do not show outer quotes");
//			ok($cache.getKey(url, testReq2) == "/test[a:3,b:6,blah:[object Object]]", "cacheKeys toString nested objects");
//
//			$cache.newType("aNewType");
//			$cache.listen(/^aNewType:set/, function(val, type) {
//				ok(type === "aNewType:set:/aTest", "custom event is fired for typeId:set:cacheKey");
//				ok(val === $cache.get("aNewType", "/aTest"), "bin is passed to callback");
//			});
//
//			var bin = $cache.set("aNewType", "/aTest", null, testVal, testMetaData);
//
//			ok(bin.typeId == "aNewType", "bins store the typeId");
//			ok(bin.key == "/aTest", "bins store the cacheKey");
//			ok(bin.url == "/aTest", "bins store the url");
//			ok(bin.req == null, "bins store the req");
//			ok(bin.val == testVal, "bins store the val");
//			ok(typeof bin.setAt == "number", "bins store a timestamp for last update");
//
//			// remove all listeners on the cache to reduce test noises
//			$cache.ignore();
//
//			$cache.set("aNewType", "/aTest", {param:1}, 1, testMetaData);
//			$cache.set("aNewType", "/aTest", {param:2}, 2, testMetaData);
//			$cache.set("aNewType", "/aTest", {param:3}, 3, testMetaData);
//			$cache.set("aNewType", "/aTest", {param:4}, 4, testMetaData);
//
//			var origLen = $length($cache.get("aNewType").bins),
//				evicted = 0;
//
//			$cache.listen(/^aNewType:evict/, function(val, type) {
//				ok(type === "aNewType:evict:"+val.key, "custom event is fired for typeId:evict:cacheKey");
//				evicted++;
//			});
//
//			var ev = $cache.evict("aNewType", function(bin, key) {
//				// should evict 2 items with even values
//				return (bin.val%2);
//			});
//
//			var newLen = $length($cache.get("aNewType").bins);
//
//			ok(ev.evicted === evicted, "evicted two items");
//			ok(ev.total === origLen, "processed "+origLen+" items");
//			ok(ev.remain === newLen, newLen+" items remain");
//		});
//
//
//		test("loot.sauce.newRemoteType", function() {
//
//			$.mockjax({
//				url: '/test3',
//				responseTime: 200,
//				status: 200, // 500 error
//				response: function() {
//					this.responseText = JSON.stringify({msg: "Hello world!"});
//				}
//			});
//			$.mockjax({
//				url: '/err3',
//				responseTime: 200,
//				status: 500, // 500 error
//				response: function() {
//					this.responseText = "error";
//				}
//			});
//
//			var myRemoteType = $cache.newRemoteType("remote1", {
//				baseUrl: "/test3"
//			});
//
//			stop();
//
//			var successCalled = 0,
//				startCalled = 0,
//				xhr = myRemoteType.sync({param:5}, {
//				start: function(msg, type) {
//					console.log(type);
//					console.log(msg);
//					console.log(this);
//					startCalled++;
//				},
//				success: function(msg, type) {
//					console.log(type);
//					console.log(msg);
//					console.log(this);
//					successCalled++;
//					ok(startCalled == 1, "start method was called");
//					ok(successCalled == 1, "success method was called");
//					start()
//				},
//				error: function(msg, type) {
//					console.log(type);
//					console.log(msg);
//					console.log(this);
//				}
//			});
//		});

	</script>
</head>

<body>
	<h1 id="qunit-header">QUnit Test Suite</h1>
	<h2 id="qunit-banner"></h2>
	<div id="qunit-testrunner-toolbar"></div>
	<h2 id="qunit-userAgent"></h2>
	<ol id="qunit-tests"></ol>
	<div id="qunit-fixture">test markup</div>
</body>
</html>