<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8" />
	<title>QUnit Test Suite</title>
	<link rel="stylesheet" href="qunit/qunit.css" type="text/css" media="screen">
	<script type="text/javascript" src="qunit/qunit.js"></script>
	<script type="text/javascript" src="../lib/jquery-1.6.js"></script>
	<script type="text/javascript" src="jquery.mockjax.js"></script>
	<script type="text/javascript" src="../src/loot.js"></script>
	<script type="text/javascript" src="../src/loot.sauce.js"></script>
	<script type="text/javascript">

		module("loot");

		test("$new", function() {

			expect(13);

			var person = {
				firstName: "john",
				age: 30
			};

			var jim = $new(person);
			jim.firstName = "jim";

			ok(person.firstName == "john", "changes to new instance do not affect original object");
			ok(person.age == "30", "untouched properties on new instance inherit values form original object");
			ok(jim.firstName == "jim", "changes to new instance took place");
			delete jim.firstName;
			ok(jim.firstName == "john", "deleting modification on new instance allows original value to shine through");
			delete jim.firstName;
			ok(person.firstName == "john", "deleting inherited value has no effect on origin");
			ok(jim.firstName == "john", "deleting inherited value has no effect on new instance");
			person.age = 0;
			ok(jim.age === 0, "modifications on original get inherited by new instance");

			var initScope,
				initTest = $new({
					initialize: function() {
						initScope = this;
						var sharedSecret = "shared";
						this.getSharedSecret = function() {
							return sharedSecret;
						};
						this.setSharedSecret = function(val) {
							sharedSecret = val;
						};
					}
				});

			equals(initScope, initTest, "initialize function is properly called");
			equals(initTest.initialize, null, "initialize function is nulled out after being called");
			equals(initTest.getSharedSecret(), "shared", "initialize function enables providing access to private members");

			var sharingSecrets = $new(initTest);
			equals(sharingSecrets.getSharedSecret(), "shared", "shared closures via an ancestors initialize function allows shared access to the same private members throughout the inheritance chain");
			sharingSecrets.setSharedSecret("changed");
			equals(initTest.getSharedSecret(), "changed", "modifications to shared closures from child to ancestor");
			initTest.setSharedSecret("changed");
			equals(sharingSecrets.getSharedSecret(), "changed", "modifications to shared closures from ancestor to child");
		});


		test("messaging with $speak", function() {
			expect(29);

			var myBlankSpeaker = $speak({name:"myBlankSpeaker"});

			ok($isSpeaker(myBlankSpeaker), "calling $speak without arguments returns a new speaker");

			var mySpeaker = $speak({
				name: "mySpeaker",
				firstName: "",
				age: 0
			});

			var mySpeaker3 = $speak({
				firstName: "",
				age: 0
			});

			ok($isSpeaker(mySpeaker), "calling $speak with arguments returns a new speaker");

			ok($isSpeaker(myBlankSpeaker) && $isSpeaker(myBlankSpeaker), "$isSpeaker works properly");

			myBlankSpeakerTestResponses = 0;
			myBlankSpeakerTestLastTopic = null;
			myBlankSpeakerTestLastMessage = null,
			myBlankSpeakerTestLastSpeaker = null,
			myBlankSpeakerTestLastScope = null,
			myBlankSpeaker.listen("test", function(topic, message, speaker) {
				myBlankSpeakerTestResponses++;
				myBlankSpeakerTestLastTopic = topic;
				myBlankSpeakerTestLastMessage = message;
				myBlankSpeakerTestLastSpeaker = speaker;
				myBlankSpeakerTestLastScope = this;

			});

			mySpeakerTestResponses = 0;
			mySpeakerTestLastTopic = null;
			mySpeakerTestLastMessage = null,
			mySpeakerTestLastSpeaker = null,
			mySpeakerTestLastScope = null,
			mySpeaker.listen("test", function(topic, message, speaker) {
				if(mySpeakerTestResponses > 20){return;}
				console.log(arguments);
				console.log((speaker && speaker === myBlankSpeaker));
				mySpeakerTestResponses++;
				mySpeakerTestLastTopic = topic;
				mySpeakerTestLastMessage = message;
				mySpeakerTestLastSpeaker = speaker;
				mySpeakerTestLastScope = this;
			});

			myBlankSpeaker.tell("test", "this is a test");
			ok(myBlankSpeakerTestResponses == 1, "properly responded to simple tell");
			ok(myBlankSpeakerTestLastTopic == "test", "properly received the topic as first arg");
			ok(myBlankSpeakerTestLastMessage == "this is a test", "responder received the message as second arg");
			ok(myBlankSpeakerTestLastSpeaker == undefined, "properly received undefined for speaker in 3rd arg since not a shared message");
			ok(myBlankSpeakerTestLastScope == myBlankSpeaker, "scope was properly the speaker that was told");

			ok(mySpeakerTestResponses == 0, "message was not shared with others");



			mySpeaker.listensTo(myBlankSpeaker);

			myBlankSpeaker.tell("test", "this is a test with sharing");
			ok(myBlankSpeakerTestResponses == 2, "properly responded to simple tell");
			ok(myBlankSpeakerTestLastMessage == "this is a test with sharing", "responder received the message");

			ok(mySpeakerTestResponses == 1, "properly responded to shared message");
			equals(mySpeakerTestLastTopic, "test", "properly received the shared topic as first arg");
			ok(mySpeakerTestLastMessage == "this is a test with sharing", "responder received the message as second arg");
			ok(mySpeakerTestLastSpeaker == myBlankSpeaker, "properly received the original speaker for speaker in 3rd arg since it was a shared message");
			ok(mySpeakerTestLastScope == mySpeaker, "scope was properly the speaker that was told");

			mySpeaker3TestResponses = 0;
			mySpeaker3TestLastTopic = null;
			mySpeaker3TestLastMessage = null,
			mySpeaker3TestLastSpeaker = null,
			mySpeaker3TestLastScope = null,
			mySpeaker3.listen("test", function(topic, message, speaker) {
				mySpeaker3TestResponses++;
				mySpeaker3TestLastTopic = topic;
				mySpeaker3TestLastMessage = message;
				mySpeaker3TestLastSpeaker = speaker;
				mySpeaker3TestLastScope = this;
			});

			mySpeaker.talksTo(mySpeaker3);
			myBlankSpeaker.tell("test", "this is a test with a sharing chain");
			
			ok(mySpeaker3TestResponses == 1, "third party (2nd share) properly responded to");
			ok(mySpeaker3TestLastTopic == "test", "properly received the topic as first arg");
			ok(mySpeaker3TestLastMessage == "this is a test with a sharing chain", "responder received the message as second arg");
			ok(mySpeaker3TestLastSpeaker == myBlankSpeaker, "properly received undefined for speaker in 3rd arg since not a shared message");
			ok(mySpeaker3TestLastScope == mySpeaker3, "scope was properly the speaker that was told");

			mySpeaker3.selectiveHearing = function(topic, message, speaker) {
				ok(this === mySpeaker3, "selective hearing function properly scoped");
				ok(speaker === undefined, "selective hearing speaker undefined for non shared messages");
				return !(topic == "test"); // ignore test messages
			};
			mySpeaker3.tell("test", "testing selectiveHearing");
			ok(mySpeaker3TestResponses == 1, "selective hearing ignores items when truth test returns false");


			mySpeaker3.selectiveHearing = function(topic, message, speaker) {
				ok(this === mySpeaker3, "selective hearing function properly scoped");
				ok(speaker === mySpeaker, "selective hearing speaker properly ser for shared messages");
				return (topic == "test"); // ignore all but test messages
			};

			mySpeaker.tell("test", "testing selectiveHearing again");
			ok(mySpeaker3TestResponses == 2, "selective hearing listens to items when truth test returns true");

			// regex listeners
			var regexListener = $speak(),
				regexListenerMatched = 0;

			regexListener.listen(/^test/, function() {
				regexListenerMatched++;
			});

			regexListener.tell("test:", "this is a tes");
			regexListener.tell("test:value", "this is a tes");
			regexListener.tell("test:value:blah", "this is a tes");
			ok(regexListenerMatched === 3, "regex listeners work!");


			// compound event type with implicit callback mapping
			var implicitCallbacks = $speak(),
				implicitCalls = 0,
				commonHandler = function(type, msg) {
					console.log(arguments);
					implicitCalls++;
				};

			implicitCallbacks.listen("test:", {
				"\\d{3}": commonHandler,
				start: commonHandler,
				error: commonHandler,
				yo: commonHandler,
				dawg: commonHandler
			});

			// these should not work
			implicitCallbacks.tell("test:", "this is a tes");
			implicitCallbacks.tell("test:1", "this is a tes");

			// these should work
			implicitCallbacks.tell("test:start", "this is a tes");
			implicitCallbacks.tell("test:error", "this is a tes");
			implicitCallbacks.tell("test:123", "this is a tes");
			ok(implicitCalls === 3, "imlicitly typed listeners work!");


		});


		test("$make", function() {
			expect(15);

			var aPerson = {
				firstName: "",
				age: 0,
				language: "en"
			};

			var aParent = $new(aPerson);
			aParent.firstName = "john";
			aParent.lastName = "doe";
			aParent.age = 40;
			aParent.city = "nevis";
			aParent.state = "MN";
			aParent.language = "cz";


			var aKid = $new(aPerson);
			aKid.firstName = "jim";
			aKid.age = 12;


			var aStudent = $new(aPerson);
			aStudent.school = "ISD 128";
			aStudent.grade = 5;

			// basic make behavior: prototype, extension, mixin
			var jim = $make(aParent, aKid, aStudent);

			equals(jim.language, "en", "inherited property on extender overwrites the prototype inherited value, while mixin inherited property is ignored");
			equals(jim.age, 12, "extension property overwrites inherited property from prototype");
			equals(aStudent.age, 0, "mixin inherits age == 0");
			equals(jim.age, 12, "property inherited on mixin is not applied");
			equals(jim.grade, 5, "property local to mixin is applied");
			equals(jim.lastName, "doe", "prototype property exists when not set by extension or mixin");

			aKid.age = 15;
			equals(jim.age, 12, "there is NO prototypal inheritance between new object and extension object");
			aStudent.grade = 8;
			equals(jim.grade, 5, "there is NO prototypal inheritance between new object and mixin object");
			aParent.lastName = "johnson";
			equals(jim.lastName, "johnson", "there IS prototypal inheritance between new object and prototype object");
			aPerson.country = "us";
			equals(aParent.country, "us", "prototype inherits new properties when they are added to its prototype object");
			equals(jim.country, "us", "inheritance chaining: new object also inherits new properties when they are added to its prototype's prototype object");

			// afterMake callback support
			var afterProtoMake = 0,
				afterextensionMake = 0,
				afterMixinMake = 0;

			var afterMakeTester = $make({
					afterMake: function() {
						afterProtoMake = this;
					}
				},{
					afterMake: function() {
						afterextensionMake = this;
					}
				},{
					afterMake: function() {
						afterMixinMake = this;
					}
				});

			equals(afterMakeTester, afterProtoMake, "afterMake on prototype called properly");
			equals(afterMakeTester, afterextensionMake, "afterMake on extender called properly");
			equals(afterMakeTester, afterMixinMake, "afterMake on mixin called properly");
			equals(afterMakeTester.afterMake, null, "afterMake is nulled out on new object");

		});




		test("$make + $speak integration", function() {

			expect(8);

			aTestResponsesMA = 0;
			var myAudience = $speak({name:"myAudience"}).listen("aTest", function(subject, message, source) {
				aTestResponsesMA++;
			});

			aTestResponsesMM = 0;
			var myMessenger = $speak({name: "myMessenger"}).listen("aTest", function(subject, message, source) {
				aTestResponsesMM++;
			}).talksTo(myAudience);

			var newMessenger = $make(myMessenger, {name: "newMessenger"});

			same(newMessenger._listeners, [], "_listeners array is cleared out so we don't inherit/share them");
			same(newMessenger._audience, [], "_audience array is cleared out so we don't inherit/share audiences");



			aTestResponsesNM = 0;
			newMessenger.listen("aTest", function(subject, message, source) {
				aTestResponsesNM++;
			});

			myMessenger.tell("aTest", "this is a test");

			equals(aTestResponsesMM, 1, "preexisting handlers work as expected");
			equals(aTestResponsesMA, 1, "preexisting message sharing works as expected");
			equals(aTestResponsesNM, 0, "events do not bubble by default");

			var forceBubble = $make(myMessenger, {name: "forceBubble", shareMessages: true});
			aTestResponsesFB = 0;
			forceBubble.listen("aTest", function(subject, message, source) {
				aTestResponsesFB++;
			});

			myMessenger.tell("aTest", "this is a test");
			equals(aTestResponsesFB, 1, "shareMessages attribute makes new object listen to prototype messages");

			var inheritBubble = $make(forceBubble, {name: "inheritBubble"});
			aTestResponsesIB = 0;
			inheritBubble.listen("aTest", function(subject, message, source) {
				aTestResponsesIB++;
			});

			myMessenger.tell("aTest", "this is a test");
			equals(aTestResponsesIB, 1, "shareMessages attribute persists as you make new objects creating a chain of message sharing (bubbling)");

			var preventBubble = $make(inheritBubble, {name: "preventBubble", dontShareMessages: true});
			aTestResponsesPB = 0;
			preventBubble.listen("aTest", function(subject, message, source) {
				aTestResponsesPB++;
			});

			myMessenger.tell("aTest", "this is a test");
			equals(aTestResponsesPB, 0, "dontShareMessages=true property can be used to break the message chain");


		});


		test("$deepCopy", function() {

			expect(5);

			var objA = {name: "objA"};
			var objB = {name: "objB", testObj: {array:[1, "string", {object:{name:"hey", age: 23} }, [0,2, 3, 5, [0, 0, 0]] ], func: function(){return this;}}};

			var aCopy = $deepCopy(objA);
			same(aCopy, objA, "deep copy of a simple object works");

			objA.name = "objectA";
			ok(aCopy.name === "objA", "changes on simple object do not transfer to copy");

			var bCopy = $deepCopy(objB);
			same(bCopy, objB, "deep copy of a complex object works");

			objB.testObj.array[2].object.name = "yo";
			ok(bCopy.testObj.array[2].object.name === "hey", "changes on complex object do not transfer to copy");

			var b2Copy = $new(objB);
			b2Copy.name = "b2";
			b2Copy.custom = "owned";

			var base = {
				name: "b2",
				custom: "owned"
			};

			var newB = $deepCopy(b2Copy, function(key, source) {
				return source.hasOwnProperty(key);
			});

			same(newB, base, "filter function works properly");

		});


		test("$deepMerge", function() {

			expect(3);

			var objA = {name: "objA"};
			var objB = {name: "objB", custom: "owned", testObj: {array:[1, "string", {object:{name:"hey", age: 23} }, [0,2, 3, 5, [0, 0, 0]] ], func: function(){return this;}}};

			$deepMerge(objA, objB);
			same(objB, objA, "properly augments the provided target object");

			// test filter method that only allows owned properties
			var b2Copy = $new(objB);

			var base = {
				name: "b2",
				custom: "owned"
			};

			var augment = {
				name: "b2",
				custom: "owned"
			};

			$deepMerge(augment, b2Copy, function(key, source) {
				return source.hasOwnProperty(key);
			});

			same(augment, base, "filter function works properly");


			$deepMerge(augment, b2Copy);

			same(augment, b2Copy, "will copy over inherited properties by default");

		});


		test("loot.sauce.io", function() {

			expect(20);

			// setup mock data source
			$.mockjax({
				url: '/test',
				responseTime: 200,
				status: 200, // 500 error
				response: function() {
					this.responseText = JSON.stringify({msg: "Hello world!"});
				}
			});

			$.mockjax({
				url: '/err',
				responseTime: 200,
				status: 500, // 500 error
				response: function() {
					this.responseText = "error";
				}
			});

			stop();

			$sauce.io.listen("io:start:", function(type, msg) {
				console.log(type);
				console.log(msg);
				ok(type.match(/^io:start/), "io:start event fires");
				ok(this == $sauce.io, "'this' is sauce.io");
			});

			$sauce.io.listen("io:success", function(type, msg) {
				console.log(type);
				console.log(msg);
				ok(type.match(/^io:success/), "io:success event fires");
				ok(msg.val.msg == "Hello world!", "received the message");
				ok(msg.req.b == 4, "received the original req");
				ok(msg.xhr, "received the xhr");
				ok(msg.url == "/test", "received the url");
				ok(this == $sauce.io, "'this' is sauce.io");
			});


			$sauce.io.listen("io:error", function(type, msg) {
				console.log(type);
				console.log(msg);
				ok(type.match(/^io:error/), "io:error event fires");
				ok(this == $sauce.io, "'this' is sauce.io");
				start();
			});

			$sauce.io("/test", {b:4, a:1});
			$sauce.io("/test", {b:4, a:1});
			$sauce.io("/err", {b:4, a:1});

		});

		test("loot.sauce.io more io", function() {

			expect(5);

			$.mockjax({
				url: '/test2',
				responseTime: 200,
				status: 200, // 500 error
				response: function() {
					this.responseText = JSON.stringify({msg: "Hello world!"});
				}
			});

			// alternate one-off non-pub-sub syntax for io with start, success and error handlers
			var startFired = 0,
				successFired = 0,
				errorFired = 0;

			stop();

			console.log("non evented callbacks");
			$sauce.io.stopListening();

			setTimeout(function() {
				$sauce.io("/test2", {b:5, a:3}, {
					start: function(type, msg) {
						console.log(type);
						console.log(msg);
						startFired++;
						ok(type.match("io:start"), "io:start event fires");
						ok(this == $sauce.io, "'this' is sauce.io");
					},
					success: function(type, msg) {
						console.log(type);
						console.log(msg);
						successFired++;
						ok(type.match("io:success"), "io:success event fires");
						ok(this == $sauce.io, "'this' is sauce.io");
						ok(errorFired === 0, "error handler didn't fire");
					},
					error: function(type, msg) {
						console.log(type);
						console.log(msg);
						errorFired++;
					}
				});
			}, 500);

			setTimeout(function() {
				start();
			},1000);

		});


		test("loot.sauce.cache", function() {

			expect(16);

			var url = "/test",
				testReq1 = {a:3, b:6, blah:"text"},
				testReq2 = {a:3, b:6, blah:{h:5}},
				testVal = {my:"val"},
				testMetaData = {more:"metadata"};

			ok($cache.getKey(url) == "/test", "cacheKeys use just the url if no req provided");
			ok($cache.getKey(url, testReq1) == '/test[a:3,b:6,blah:text]', "cacheKeys stringify req objects, strings do not show outer quotes");
			ok($cache.getKey(url, testReq2) == "/test[a:3,b:6,blah:[object Object]]", "cacheKeys toString nested objects");

			$cache.newType("aNewType");
			$cache.listen(/^aNewType:set/, function(type, val) {
				ok(type === "aNewType:set:/aTest", "custom event is fired for typeId:set:cacheKey");
				ok(val === $cache.get("aNewType", "/aTest"), "bin is passed to callback");
			});

			var bin = $cache.set("aNewType", "/aTest", null, testVal, testMetaData);

			ok(bin.typeId == "aNewType", "bins store the typeId");
			ok(bin.key == "/aTest", "bins store the cacheKey");
			ok(bin.url == "/aTest", "bins store the url");
			ok(bin.req == null, "bins store the req");
			ok(bin.val == testVal, "bins store the val");
			ok(typeof bin.set == "number", "bins store a timestamp for last update");

			// remove all listeners on the cache to reduce test noises
			$cache.stopListening();

			$cache.set("aNewType", "/aTest", {param:1}, 1, testMetaData);
			$cache.set("aNewType", "/aTest", {param:2}, 2, testMetaData);
			$cache.set("aNewType", "/aTest", {param:3}, 3, testMetaData);
			$cache.set("aNewType", "/aTest", {param:4}, 4, testMetaData);

			var origLen = $length($cache.get("aNewType").bins),
				evicted = 0;

			$cache.listen(/^aNewType:evict/, function(type, val) {
				ok(type === "aNewType:evict:"+val.key, "custom event is fired for typeId:evict:cacheKey");
				evicted++;
			});

			var ev = $cache.evict("aNewType", function(bin, key) {
				// should evict 2 items with even values
				return (bin.val%2);
			});

			var newLen = $length($cache.get("aNewType").bins);

			ok(ev.evicted === evicted, "evicted two items");
			ok(ev.total === origLen, "processed "+origLen+" items");
			ok(ev.remain === newLen, newLen+" items remain");
		});


		test("loot.sauce.newRemoteType", function() {

			$.mockjax({
				url: '/test3',
				responseTime: 200,
				status: 200, // 500 error
				response: function() {
					this.responseText = JSON.stringify({msg: "Hello world!"});
				}
			});
			$.mockjax({
				url: '/err3',
				responseTime: 200,
				status: 500, // 500 error
				response: function() {
					this.responseText = "error";
				}
			});

			var myRemoteType = $cache.newRemoteType("remote1", {
				baseUrl: "/test3"
			});

			stop();

			var successCalled = 0,
				startCalled = 0,
				xhr = myRemoteType.sync({param:5}, {
				start: function(type, msg) {
					console.log(type);
					console.log(msg);
					console.log(this);
					startCalled++;
				},
				success: function(type, msg) {
					console.log(type);
					console.log(msg);
					console.log(this);
					successCalled++;
					ok(startCalled == 1, "start method was called");
					ok(successCalled == 1, "success method was called");
					start()
				},
				error: function(type, msg) {
					console.log(type);
					console.log(msg);
					console.log(this);
				}
			});


		});

	</script>
</head>

<body>
	<h1 id="qunit-header">QUnit Test Suite</h1>
	<h2 id="qunit-banner"></h2>
	<div id="qunit-testrunner-toolbar"></div>
	<h2 id="qunit-userAgent"></h2>
	<ol id="qunit-tests"></ol>
	<div id="qunit-fixture">test markup</div>
</body>
</html>